#!/bin/bash

## Usage info
show_help() {
cat << EOF
Usage: ${0##*/} [-hv] -c CERT_CN [-n CERT_NAME] [-Y] [OPTIONS] FQDN
This script requests a certificate from FreeIPA using ipa-getcert and calls a partner
script to deploy the certificate to a Palo Alto firewall or Panorama.

    FQDN                Fully qualified name of the Palo Alto firewall or Panorama
                        interface. Must be reachable from this host on port TCP/443.
    -c CERT_CN          REQUIRED. Common Name of the certificate (must be an FQDN). Will
                        be added as to the certificate as a SAN.

OPTIONS:
    -n CERT_NAME        Name of the certificate in PanOS configuration. Defaults to the
                        certificate Common Name.
    -s PROFILE_NAME     Apply the certificate to a SSL/TLS Service Profile.
                        (For example for a management interface).
    -p [PROFILE_NAME]   Apply the certificate to a GlobalProtect SSL/TLS Service Profile
                        used on the Portal. Omit this option to avoid automatic linking.
                        Default profile name: GP_PORTAL_PROFILE
    -g [PROFILE_NAME]   Apply the certificate to a GlobalProtect SSL/TLS Service Profile
                        used on the Gateway. Omit this option to avoid automatic linking.
                        Default proifile name: GP_EXT_GW_PROFILE
    -Y                  Append the current year '_YYYY' to the certificate name. Also
                        when the certificate is automatically renewed by ipa-getcert.

    -h                  Display this help and exit.
    -v                  Verbose mode.
EOF
}

## Fixed variables
INST_CERT="/usr/local/bin/pan_instcert"
API_KEY="/etc/ipa/.panrc"
TEMP_PWD=$(openssl rand -hex 15)
TEMP_PFX="/tmp/getcert_pkcs12.pfx"
VERBOSE=0
OPTIND=1

## Read/interpret optional arguments
while getopts c:n:s:pgvh opt; do
    case $opt in
        c)  CN_FQDN=$OPTARG
            ;;
        n)  CERT_NAME=$OPTARG
            ;;
        Y)  YEAR="_$(date +'%Y')"
            ;;
        s)  SSL_TLS_PROFILE=$OPTARG
            ;;
        p)  eval nextopt=${!OPTIND}
            if [[ -n $nextopt && $nextopt != -* ]] ; then
                OPTIND=$((OPTIND+1))
                if [[ "$nextopt" =~ (^[\w-]+$) ]]; then
                    GP_PORTAL_TLS_PROFILE=$nextopt
                else
                    printf 'ERROR: Invalid GP_PORTAL_TLS_PROFILE given: <%s>\n' "$nextopt"
                    printf 'Ensure the name does not contain dots or spaces.\n'
                    exit 2
                fi
            else
                GP_PORTAL_TLS_PROFILE=GP_PORTAL_PROFILE
            fi
            ;;
        p)  eval nextopt=${!OPTIND}
            if [[ -n $nextopt && $nextopt != -* ]] ; then
                OPTIND=$((OPTIND+1))
                if [[ "$nextopt" =~ (^[\w-]+$) ]]; then
                    GP_GW_TLS_PROFILE=$nextopt
                else
                    printf 'ERROR: Invalid GP_GW_TLS_PROFILE given: <%s>\n' "$nextopt"
                    printf 'Ensure the name does not contain dots or spaces.\n'
                    exit 3
                fi
            else
                GP_GW_TLS_PROFILE=GP_EXT_GW_PROFILE
            fi
            ;;
        v)  VERBOSE=$((VERBOSE+1))
            ;;
        h)  show_help
            exit 0
            ;;
        *)  show_help >&2
            exit 1
            ;;
    esac
done
shift "$((OPTIND-1))"   # Discard the options and sentinel --

# Check that a Common Name name was given
if [[ -z $CERT_CN ]]; then
    printf 'ERROR: Missing -c, a certificate requires a Common Name.\n\n'
    show_help >&2
    exit 1
elif [[ "$CERT_CN" =~ (?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63}$) ]]; then
    $CERT_CN=${CERT_CN,,}
    if (( $VERBOSE > 0 )); then
        printf 'Certificate Common Name: <%s>' "$CERT_CN"
    fi
fi
if [[ -z $CERT_NAME ]]; then
    $CERT_NAME=$CERT_CN
elif (( $VERBOSE > 0 )); then
    printf 'Parsed certificate Name: <%s>' "$CERT_NAME"
fi

# Check that a single valid FQDN was parsed for the Palo Alto API interface
if [[ "$@" =~ (?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63}$) ]]; then
    PAN_MGMT="${@,,}"
    printf 'verbose=<%d>\nCERT_CN=<%s>\nCERT_NAME=<%s>\nFQDN=<%s>\n' "$VERBOSE" "$CERT_CN" "$CERT_NAME$YEAR" "$PAN_MGMT"
    if ! nc -z $PAN_MGMT 443 2>/dev/null; then
        printf 'ERROR: Palo Alto device unreachable at: https://<%s>/\n' "$PAN_MGMT"
        exit 4
    fi
else
    printf 'ERROR: A valid FQDN is required to issue a certificate.\n'
    printf 'Parsed string: <%s>\n\n' "$@"
    show_help >&2
    exit 4
fi

# Verbose stdout of SSL/TLS profiles (if any)
if (( $VERBOSE > 0 )) && [[ ! -z $SSL_TLS_PROFILE ]]; then
    printf 'SSL/TLS profile SSL_TLS_PROFILE=<%s>\n' "$SSL_TLS_PROFILE"
elif (( $VERBOSE > 0 )) && [[ ! -z $GP_PORTAL_TLS_PROFILE || ! -z $GP_GW_TLS_PROFILE ]]; then
    printf 'SSL/TLS profile GP_PORTAL_TLS_PROFILE=<%s>\nSSL/TLS profile GP_GW_TLS_PROFILE=<%s>\n' "$GP_PORTAL_TLS_PROFILE" "$GP_GW_TLS_PROFILE"
elif (( $VERBOSE > 0 )); then
    echo "No SSL/TLS profiles parsed."
fi

## Requirements
# Installed packages: ipa-getcert

# Ensure the host is enrolled into an IPA server and the folder for certificate chain storage exists.
REALM=$(realm discover -n)
if [ $? -eq 0 ]; then
    echo 'ERROR: Realm not found. This script must be run from an enrolled FreeIPA client.'
    exit 5
fi
if [ -d /etc/ipa ]; then
    sudo mkdir -m 0700 -p /etc/ipa/ssl
    if [ $? -eq 0 ]; then
        printf 'ERROR: /etc/ipa/ssl could not be created.\n'
        printf 'Ensure you have sudo rights to create this folder, or have it created for you\nowned by root and with privileges set to: 0700.\n'
    exit 6
else
    echo 'ERROR: /etc/ipa/ does not exist. This script must be run from an enrolled FreeIPA client.'
    exit 5
fi

## Request the certificate from FreeIPA
if [[ ! -z $SSL_TLS_PROFILE ]]; then
    INST_OPTS="-s $SSL_TLS_PROFILE"
else
    if [[ ! -z $GP_PORTAL_TLS_PROFILE ]]; then
        INST_OPTS="-p $GP_PORTAL_TLS_PROFILE"
    fi
    if [[ ! -z $GP_GW_TLS_PROFILE ]]; then
        INST_OPTS="$INST_OPTS -g $GP_GW_TLS_PROFILE"
    fi
fi
# The Service Principals are assumed to exist, if they don't the status will not be MONITORING.
if [[ -z $YEAR ]]; then
    sudo ipa-getcert request -N $CERT_CN -K HTTP/$CERT_CN -k /etc/ssl/private/${CERT_CN}.key -f /etc/ssl/certs/${CERT_CN}.crt \
    -D $CERT_CN -C "$INST_CERT -n $CERT_NAME $INST_OPTS $PAN_MGMT"
else
    sudo ipa-getcert request -N $CERT_CN -K HTTP/$CERT_CN -k /etc/ssl/private/${CERT_CN}.key -f /etc/ssl/certs/${CERT_CN}.crt \
    -D $CERT_CN -C "$INST_CERT -n ${CERT_NAME}_"'$(date +"%Y")'" $INST_OPTS $PAN_MGMT"
fi
if (( $VERBOSE > 0 )); then
    printf 'Certificate requested for: <%s>' "$CERT_CN"
fi

# Verify state of the certificate is MONITORING
CERT_STATUS=$(sudo ipa-getcert status -f /etc/ssl/certs/${CERT_CN}.crt -v)
if ! [[ $CERT_STATUS =~ "MONITORING" ]]; then
    printf 'ERROR: Problem encountered with the requested certificate.\nManual intervention required for: <%s>.\n' "$CERT_CN"
    printf 'Certificate request <%s>\n' "${CERT_STATUS,}"
    exit 10
else
    printf 'SUCCESS: Certificate issued for: <%s>.\nProceeding with installation to: <%s>.\n' "$CERT_CN" "$PAN_MGMT"
    #$INST_CERT -n $CERT_NAME$YEAR $INST_OPTS $PAN_MGMT" # post-save may work on initial issue of the certificate -- TO BE VERIFIED
fi
